
\subsection{L'\english{Internal Configuration Access Port}}

L'ICAP (\english{Internal Configuration Access Port}) est une version interne de l'interface SelectMap qui permet de configurer de manière rapide des \fpgas{} haut de gamme \brand{Xilinx}.\\
L'ICAP est une interface accessible depuis l'intérieur du \fpga{} qui lui permet de se reconfigurer de manière autonome à partir de différents media : Flash, Ram, UART, Ethernet.\\
L'horloge qui permet de synchroniser l'échange de donnée peut aller jusqu'à 100MHz. \brand{Xilinx} rajoute à la fin de ses fichiers de bitstreams une somme de contrôle. L'ICAP est donc capable de détecter le chargement d'un fichier invalide. Il y a deux types d'erreurs, les erreurs de données et les erreurs d'adresses. Pour le premier type d'erreur, il suffit de remettre en place l'instance précédente correspondant à la tranche qu'on a essayé de reconfigurer. Par contre les erreurs d'adresses peuvent entraîner une modification des parties statiques et une reprogrammation de tout le \fpga{}. Le concepteur peut mettre lui même en place un système de vérification du bitstream et le vérifier avant de l'envoyer sur l'ICAP.\\
Le protocole de reconfiguration n'indique pas la fin de la reprogrammation. Pour la détecter, il faut observer le flux de bits qui traverse l'ICAP et découvrir le mot \english{DESYNCH}. Ce mot est généralement précédé de nombreux octets de \english{padding} qui assurent que le \fpga{} est bien configuré avant la fin de la lecture du fichier.

\subsection{Comparatif de cryptographie avec software et sur hardware}

Une fois la reconfiguration partielle fonctionnelle, il serait intéressant de comparer le temps d'exécution d'une fonction de cryptage codée algorithmiquement ou en utilisant un module matériel spécifique. Notre première idée était de réaliser ce test avec une application de sécurité de chiffrage. Nous avons trouvé des bibliothèques en \languagetoto{C} et en \languagetoto{C++} offrant des services cryptographiques comme \href{http://www.cryptopp.com/}{Crypto++} ainsi que des modules Verilog sur \href{http://opencores.org/}{OpenCores} comme celui du projet \href{http://opencores.org/project,tiny_aes}{tiny\_aes}. L'idéal aurait été de stocker le programme \languagetoto{C++} sur la Flash, de créer un \english{testbench} et de l'exécuter via le pseudo-terminal.

\subsection{Développement d'une bibliothèque d'outils reconfigurables}

L'idée finale de notre projet tutoré était d'utiliser la \english{partial reconfiguration} afin de pouvoir mettre en place une bibliothèque de modules adaptés à des problèmes spécifiques. Cette \english{library} serait l'équivalent hardware d'une \english{library} software. Elle permettrait d'instancier des modules adaptés au besoin du moment afin d'effectuer certaines tâches. Imaginons par exemple une application qui diffuse l'image d'une webcam à travers l'Internet. Elle doit compresser la vidéo et la chiffrer. Un module spéficique chiffrerait en AES et un autre encoderait la vidéo. Ces deux modules permettraient de libérer du temps au processeur et simplifierait les opérations à exécuter, son jeu d'instructions et donc la place qu'il prend en \fpga{}.